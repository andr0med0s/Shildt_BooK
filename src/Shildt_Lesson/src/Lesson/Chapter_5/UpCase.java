package Shildt_Lesson.src.Lesson.Chapter_5;
// Побитовые операторы стр 205
// Преобразование строчных букв английского алфавита в прописные

/*
* В побитовых операторах в качестве операндов
могут выступать только значения типа long, int, short, char и byte. К типам
boolean, float, double и к классам побитовые операторы неприменимы. Эти
операторы называются побитовыми, поскольку они в основном используются
для проверки, установки и сдвига отдельных разрядов числа
* */

public class UpCase {
    public static void main(String[] args) {
        char ch;
        for (int i = 0; i < 10; i++) {
            ch = (char) ('a' + i);
            System.out.print(ch);
// В следующем операторе сбрасывается шестой бит.
// После этого в переменной ch будет храниться код
// символа прописной буквы,
            ch = (char) ((int) ch & 65503);
            System.out.print(ch + " ");
        }
    }
}

// Отображение битов, составляющих байт
class ShowBits {
    public static void main(String[] args) {
        int t;
        byte val;
        val = 123;
        for (t = 128; t > 0; t = t / 2) {
            if ((val & t) != 0) {
                System.out.print("1 ");
            } else {
                System.out.print("0 ");
            }
        }
    }
}
/*
* Здесь в цикле for последовательно проверяется каждый бит значения пере-
менной val. Для выяснения того, установлен ли бит, выполняется побитовая
операция И. Если бит установлен, отображается цифра 1, иначе — 0.
* */

// Преобразование прописных букв английского алфавита в строчные стр 208
class LowCase {
    public static void main(String[] args) {
        char ch;
        for (int i = 0; i < 10; i++) {
            ch = (char) ('A' + i);
            System.out.print(ch);
// В результате установки в единицу шестого бита
// значения переменной ch она всегда будет
// содержать прописную букву
            ch = (char) ((int) ch | 32);
            System.out.print(ch + " ");
        }
    }
}
/*
* В приведенном выше примере операндами побитовой операции ИЛИ явля-
ются код символа и значение 32 (двоичное представление — 0000000000100000).
Как видите, в двоичном представлении значения 32 установлен только шестой
бит. Используя это значение в качестве одного операнда в побитовой операции
ИЛИ с любым другим значением в качестве другого операнда, получим резуль-
тат, в котором устанавливается шестой бит, а состояние всех остальных битов
остается без изменения. Таким образом, любая прописная буква будет преоб-
разована в строчную.
* */
/*
 * последовательное применение двух побитовых операций
 * исключающего ИЛИ восстанавливает исходное значение
 * */

// Использование побитовой операции исключающего ИЛИ
// для шифрования и дешифрования сообщений
class Encode {
    public static void main(String args[]) {
        String msg = "Это просто тест";
        String encmsg = "";
        String decmsg = "";
        int key = 88;
        System.out.print("Исходное сообщение: ");
        System.out.println(msg);

        // Шифрование сообщения
        for (int i = 0; i < msg.length(); i++) {
            encmsg = encmsg + (char) (msg.charAt(i) ^ key); // ^ побитовое исключающее или
            // построение зашифрованной строки сообщения
        }
        System.out.print("Зашифрованное сообщение: ");
        System.out.println(encmsg);

        // Дешифровка сообщения
        for (int i = 0; i < msg.length(); i++) {
            decmsg = decmsg + (char) (encmsg.charAt(i) ^ key); // построение дешифрованной строки сообщения
        }
        System.out.print("Дешифрованное сообщение: ");
        System.out.println(decmsg);
    }
}

/* стр 210
* Унарная побитовая операция НЕ (или дополнение до 1) изменяет на обратное
*  состояние всех битов операнда. Так, если некоторая целочисленная
* переменная А содержит значение с двоичным представлением 10010110,
* то в результате выполнения побитовой операции ~А получится двоичная комбинация
01101001.
* */

// Демонстрация побитовой операции НЕ
class NotDemo {
    public static void main(String[] args) {
        byte b = -34;
        for (int t = 128; t > 0; t = t / 2) {
            if ((b & t) != 0) {
                System.out.print("1");
            } else {
                System.out.print("0 ");
            }
            System.out.println();
        }
        // Обращение состояния всех битов
        b = (byte) ~b; // ~ унарная операция НЕ
        for (int t = 128; t > 0; t = t / 2) {
            if ((b & t) != 0) {
                System.out.print("1 ");
            } else {
                System.out.print("0 ");
            }
        }
    }
}

//Операции побитового сдвига стр 211
/*
* Ниже приведен общий синтаксис этих операторов.
*
значение << число_битов    Сдвиг влево
значение >> число_битов    Сдвиг вправо
значение >>>  число_битов  Сдвиг вправо без знака  сдвигом с заполнением нулями
*
Здесь число_битов — это число позиций двоичных разрядов, на которое
сдвигается указанное значение.
При сдвиге влево освободившиеся младшие разряды заполняются нулями,
а при сдвиге вправо дело обстоит немного сложнее. Как известно, признаком
отрицательного целого числа является единица в старшем разряде, поэтому при
сдвиге вправо старший (знаковый) разряд сохраняется. Если число положитель­
ное, то в него записывается нуль, а если отрицательное — единица.
* */

// Демонстрация использования операторов << и >> стр 212
class ShiftDemo {
    public static void main(String[] args) {
        int val = 1;
        for (int i = 0; i < 8; i++) {
            for (int t = 128; t > 0; t = t / 2) {
                if ((val & t) != 0) {
                    System.out.print("1 ");
                }
                else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
            val = val << 1; // сдвиг влево
        }
        System.out.println();
        val = 128;
        for (int i = 0; i < 8; i++) {
            for (int t = 128; t > 0; t = t / 2) {
                if ((val & t) != 0) {
                    System.out.print("1 ");
                }
                else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
            val = val >> 1; // сдвиг вправо
        }
    }
}
/*
* Выполняя сдвиг значений типа byte и short, необходимо соблюдать осто-
рожность, поскольку исполняющая среда Java автоматически преобразует их
в тип int и лишь потом вычисляет выражение с операцией сдвига. Так, если
сдвинуть вправо значение типа byte, оно будет сначала повышено до типа int,
а результат сдвига будет также отнесен к типу int. Обычно такое преобразо-
вание не влечет за собой никаких последствий. Но если попытаться сдвинуть
отрицательное значение типа byte или short, то при повышении до типа int
оно будет дополнено знаком, а следовательно, старшие его разряды будут за-
полнены единицами. Это вполне оправдано при обычном сдвиге вправо. Но
при выполнении сдвига с заполнением нулями в байтовом представлении числа
неожиданно появятся 24 единицы, которые придется дополнительно сдвинуть,
прежде чем в нем появятся нули.
* */