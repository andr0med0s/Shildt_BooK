package Lesson.Chapter_5;
// Побитовые операторы стр 205
// Преобразование строчных букв английского алфавита в прописные

/*
* В побитовых операторах в качестве операндов
могут выступать только значения типа long, int, short, char и byte. К типам
boolean, float, double и к классам побитовые операторы неприменимы. Эти
операторы называются побитовыми, поскольку они в основном используются
для проверки, установки и сдвига отдельных разрядов числа
* */

public class UpCase {
    public static void main(String[] args) {
        char ch;
        for (int i = 0; i < 10; i++) {
            ch = (char) ('a' + i);
            System.out.print(ch);
// В следующем операторе сбрасывается шестой бит.
// После этого в переменной ch будет храниться код
// символа прописной буквы,
            ch = (char) ((int) ch & 65503);
            System.out.print(ch + " ");
        }
    }
}

// Отображение битов, составляющих байт
class ShowBits {
    public static void main(String[] args) {
        int t;
        byte val;
        val = 123;
        for (t = 128; t > 0; t = t / 2) {
            if ((val & t) != 0) {
                System.out.print("1 ");
            } else {
                System.out.print("0 ");
            }
        }
    }
}
/*
* Здесь в цикле for последовательно проверяется каждый бит значения пере-
менной val. Для выяснения того, установлен ли бит, выполняется побитовая
операция И. Если бит установлен, отображается цифра 1, иначе — 0.
* */

// Преобразование прописных букв английского алфавита в строчные стр 208
class LowCase {
    public static void main(String[] args) {
        char ch;
        for (int i = 0; i < 10; i++) {
            ch = (char) ('A' + i);
            System.out.print(ch);
// В результате установки в единицу шестого бита
// значения переменной ch она всегда будет
// содержать прописную букву
            ch = (char) ((int) ch | 32);
            System.out.print(ch + " ");
        }
    }
}
/*
* В приведенном выше примере операндами побитовой операции ИЛИ явля-
ются код символа и значение 32 (двоичное представление — 0000000000100000).
Как видите, в двоичном представлении значения 32 установлен только шестой
бит. Используя это значение в качестве одного операнда в побитовой операции
ИЛИ с любым другим значением в качестве другого операнда, получим резуль-
тат, в котором устанавливается шестой бит, а состояние всех остальных битов
остается без изменения. Таким образом, любая прописная буква будет преоб-
разована в строчную.
* */
/*
 * последовательное применение двух побитовых операций
 * исключающего ИЛИ восстанавливает исходное значение
 * */

// Использование побитовой операции исключающего ИЛИ
// для шифрования и дешифрования сообщений
class Encode {
    public static void main(String args[]) {
        String msg = "Это просто тест";
        String encmsg = "";
        String decmsg = "";
        int key = 88;
        System.out.print("Исходное сообщение: ");
        System.out.println(msg);

        // Шифрование сообщения
        for (int i = 0; i < msg.length(); i++) {
            encmsg = encmsg + (char) (msg.charAt(i) ^ key); // ^ побитовое исключающее или
            // построение зашифрованной строки сообщения
        }
        System.out.print("Зашифрованное сообщение: ");
        System.out.println(encmsg);

        // Дешифровка сообщения
        for (int i = 0; i < msg.length(); i++) {
            decmsg = decmsg + (char) (encmsg.charAt(i) ^ key); // построение дешифрованной строки сообщения
        }
        System.out.print("Дешифрованное сообщение: ");
        System.out.println(decmsg);
    }
}

/* стр 210
* Унарная побитовая операция НЕ (или дополнение до 1) изменяет на обратное
*  состояние всех битов операнда. Так, если некоторая целочисленная
* переменная А содержит значение с двоичным представлением 10010110,
* то в результате выполнения побитовой операции ~А получится двоичная комбинация
01101001.
* */

// Демонстрация побитовой операции НЕ
class NotDemo {
    public static void main(String[] args) {
        byte b = -34;
        for (int t = 128; t > 0; t = t / 2) {
            if ((b & t) != 0) {
                System.out.print("1");
            } else {
                System.out.print("0 ");
            }
            System.out.println();
        }
        // Обращение состояния всех битов
        b = (byte) ~b; // ~ унарная операция НЕ
        for (int t = 128; t > 0; t = t / 2) {
            if ((b & t) != 0) {
                System.out.print("1 ");
            } else {
                System.out.print("0 ");
            }
        }
    }
}

//Операции побитового сдвига стр 211
/*
* Ниже приведен общий синтаксис этих операторов.
*
значение << число_битов    Сдвиг влево
значение >> число_битов    Сдвиг вправо
значение >>>  число_битов  Сдвиг вправо без знака  сдвигом с заполнением нулями
*
Здесь число_битов — это число позиций двоичных разрядов, на которое
сдвигается указанное значение.
При сдвиге влево освободившиеся младшие разряды заполняются нулями,
а при сдвиге вправо дело обстоит немного сложнее. Как известно, признаком
отрицательного целого числа является единица в старшем разряде, поэтому при
сдвиге вправо старший (знаковый) разряд сохраняется. Если число положитель­
ное, то в него записывается нуль, а если отрицательное — единица.
* */

// Демонстрация использования операторов << и >> стр 212
class ShiftDemo {
    public static void main(String[] args) {
        int val = 1;
        for (int i = 0; i < 8; i++) {
            for (int t = 128; t > 0; t = t / 2) {
                if ((val & t) != 0) {
                    System.out.print("1 ");
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
            val = val << 1; // сдвиг влево
        }
        System.out.println();
        val = 128;
        for (int i = 0; i < 8; i++) {
            for (int t = 128; t > 0; t = t / 2) {
                if ((val & t) != 0) {
                    System.out.print("1 ");
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
            val = val >> 1; // сдвиг вправо
        }
    }
}
/*
* Выполняя сдвиг значений типа byte и short, необходимо соблюдать осто-
рожность, поскольку исполняющая среда Java автоматически преобразует их
в тип int и лишь потом вычисляет выражение с операцией сдвига. Так, если
сдвинуть вправо значение типа byte, оно будет сначала повышено до типа int,
а результат сдвига будет также отнесен к типу int. Обычно такое преобразо-
вание не влечет за собой никаких последствий. Но если попытаться сдвинуть
отрицательное значение типа byte или short, то при повышении до типа int
оно будет дополнено знаком, а следовательно, старшие его разряды будут за-
полнены единицами. Это вполне оправдано при обычном сдвиге вправо. Но
при выполнении сдвига с заполнением нулями в байтовом представлении числа
неожиданно появятся 24 единицы, которые придется дополнительно сдвинуть,
прежде чем в нем появятся нули.
* */

//-------------стр 117 Полное руководство
/*
* Все целочисленные типы (кроме char) являются целыми числами со зна-
ком, т.е. они могут представлять как положительные, так и отрицательные
значения. В Java используется кодировка, известная как доnолнение до двух или
доnолнumельный код, которая предусматривает представление отрицательных
чисел путем инвертирования (замены единиц на нули и наоборот) всех би-
тов в значении и последующего добавления единицы к результату. Например,
для представления -42 инвертируются все биты в 42, или 00101010, что дает
11010101, после чего к результату добавляется 1, давая в итоге 11010110, или
-42. Чтобы декодировать отрицательное число, необходимо инвертировать
все биты и добавить 1. Например, -42, или 1 10101 10, в результате инвертиро-
вания дает 00101001, или 41, а после добавления 1 получается 42.

в целочисленной математике отрицательный ноль недопустим. Эта
проблема решается за счет использования дополнения до двух для представ-
ления отрицательных значений. Когда применяется дополнение до двух, к
дополнению добавляется 1, что дает 100000000. Единичный бит оказывается
слишком далеко слева и не умещается в значение byte, что приводит к же-
лаемому поведению, где -О совпадает с О, а 11111111 является кодом для -1.

Из-за того, что в Java для хранения отрицательных чисел используется
дополнение до двух и т.к. все целые числа представляют собой значения со
знаком, применение побитовых операций может легко дать неожиданные ре-
зультаты. Например, включение старшего бита приведет к тому, что резуль-
тирующее значение будет интерпретироваться как отрицательное число, вхо-
дило это в ваши намерения или нет. Во избежание неприятных сюрпризов
просто помните, что старший бит определяет знак целого числа независимо
от того, как он был установлен.

Побитовое НЕ
Унарная операция НЕ, ~, также называемая побитовым дополнением, инвер-
тирует все биты своего операнда. Например, число 42, имеющее следующую
битовую комбинацию:
          00101010
после применения операции НЕ превращается в
          11010101

Побитовое И
Операция И, &, выдает единичный бит, если биты в обоих операндах также
равны 1. В остальных случаях выдается нулевой бит. Вот пример:
          00101010 42
        & 00001111 15
        --------------
          00001010 10
Побитовое ИЛИ
Операция ИЛИ, 1 , объединяет биты так, что если любой из битов в опе-
рандах равен 1, то результирующий бит будет единичным, как показано ниже:
         00101010 42
       | 00001111 15
       --------------
         00101111 47

Побитовое исключающее ИЛИ
Операция исключающего ИЛИ (XOR), л, объединяет биты таким образом,
что если бит в одном операнде равен 1, то результирующий бит будет еди-
ничным. В противном случае результирующий бит будет нулевым.
            00101010 42
          ^ 00001111 15
            -----------
            00100101 37
* */
// стр 119
// Демонстрация работы побитовых логических операций
class BitLogic {
    public static void main(String[] args) {
        String[] binary = {
                "0000", "0001", "0010", "0011", "0100", "0101", "0111",
                "1000", "1001", "1010", "1011", "1100", "1101", "1111",
        };
        int a = 3; // 0 + 2 + 1 или 0011 в двоичной форме
        int b = 6; // 4 + 2 + 0 или 0110 в двоичной форме
        int с = a | b; // или
        int d = a & b; // и
        int e = a ^ b; // исключающее или
        int f = (~a & b) | (a & ~b);
        int g = ~a & 0x0f;
        System.out.println("          а = " + binary[a]);
        System.out.println("          Ь = " + binary[b]);
        System.out.println("        a|b = " + binary[с]);
        System.out.println("      а & Ь = " + binary[d]);
        System.out.println("      а ^ b = " + binary[e]);
        System.out.println("~a&b | a&~b = " + binary[f]);
        System.out.println("         ~а = " + binary[g]);
    }
}
/*
* В этом примере а и b имеют битовые комбинации, которые представляют
*  все четыре возможности для двух двоичных цифр: 0-0, 0-1, 1-0 и 1-1.
Результаты в переменных с и d позволяют видеть работу с каждым битом
операций | и &. Значения, присвоенные е и f, одинаковы и иллюстрируют
работу операции ^. Массив строк по имени Ьinary содержит удобочитаемое
двоичное представление чисел от О до 15. Массив в примере индексируется
так, чтобы показать двоичное представление каждого результата. Массив
* построен таким образом, что корректное строковое представление двоичного
значения n хранится в Ьinary [n] . Значение ~а объединяется посредством
операции И с OxOf (O<IO0lll 1 в двоичной форме) для его уменьшения до
* менее чем 16, чтобы его можно было вывести с использованием массива Ьinary.
* */

/*
Сдвиг влево
Глава 4. Операции стр 119
Операция сдвига влево, <<, сдвигает все биты значения влево на указанное
количество позиций. Она имеет следующую общую форму:
значение << число
Здесь число устанавливает количество позиций для сдвига влево значения.
То есть операция << перемещает все биты в указанном значении влево на
количество битовых позиций, заданное в числе. При каждом сдвиге влево
старший бит смещается (и утрачивается), а справа вставляется ноль. Это
означает, что когда к операнду int применяется сдвиг влево, биты теряются,
как только они сдвигаются за битовую позицию 31. В случае операнда типа
long биты утрачиваются после битовой позиции 63.
* */

// Сдвиг влево значения byte .
class ByteShift {
    public static void main(String[] args) {
        byte а = 64, Ь;
        int i;
        i = а << 2;
        Ь = (byte) (а << 2);
        System.out.println("Пepвoнaчaльнoe значение а : " + а);
        System.out.println("i и Ь : " + i + " " + Ь);
    }
}

/*
* Поскольку а повышается до int для целей вычисления, сдвиг влево
значения 64 (0100 0000) дважды приводит к тому, что i содержит значение 256
(1 0000 0000). Однако значение в Ь содержит О, т.к. после сдвига младший байт
теперь равен нулю. Единственный единичный бит был сдвинут за его пределы.
Из-за того, что каждый сдвиг влево удваивает исходное значение, программисты
часто используют данный факт как эффективную альтернативу умножению на 2
* */
// Сдвиг влево как быстрый способ умножения на 2
class MultByTwo {
    public static void main(String[] args) {
        int i;
        int num = 0xFFFFFFE;
        for (i = 0; i < 4; i++) {
            num = num << 1;
            System.out.println(num);
        }
    }
}

/*Сдвиг вправо
Операция сдвига вправо, >>, сдвигает все биты значения вправо на указанное
 количество позиций. Она имеет следующую общую форму
значение >> число
Здесь число устанавливает количество позиций для сдвига вправо
значения. То есть операция >> перемещает все биты в указанном значении
вправо на количество битовых позиций, заданное в числе.

В показанном ниже фрагменте кода значение 32 сдвигается вправо на две
позиции, приводя к тому, что а устанавливается в 8:
int а = 32;
а = а >> 2; // а теперь содержит 8

Когда биты в значении смещаются за его пределы, то они утрачиваются.
Например, в следующем фрагменте кода значение 35 сдвигается на две
позиции вправо, что приводит к потере двух младших битов, в результате чего
а снова получает значение 8:
int а = 35;
а = а >> 2; // а содержит 8
Взглянув на ту же операцию в двоичной форме, становится ясно, как это
происходит:
00100011 35
>> 2
00001000 8

Каждый раз, когда выполняется сдвиг значения вправо, оно делится на 2 с
отбрасыванием любого остатка. В некоторых случаях данным фактом можно
воспользоваться для высокопроизводительного целочисленного деления на 2

*/

// Маскирование расширения знака. стр 122
class HexByte {
    static public void main(String[] args) {
        char[] hex = {
                '0', '1', '2', '3', '4', '5', '6', '7',
                '8', '9', 'а', 'Ь', 'с', 'd', 'е', 'f'
        };
        byte b = (byte) 0xf1;
        System.out.println("b = Ох" + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
    }
}
/*
* операция >> автоматически заполняет старший бит его предыдущим
*  содержимым каждый раз, когда происходит сдвиг,
сохраняя знак значения. Тем не менее, иногда это нежелательно. Например,
при выполнении сдвига чего-то, что не представляет собой числовое зна
чение, расширение знака может оказаться ненужным. Такая ситуация часто
* встречается при работе с пиксельными значениями и графикой. В ситуациях
подобного рода обычно требуется помещать в старший бит ноль вне зависимости
*  от того, каким было его начальное значение.
* */


/*
*  операция >>> часто не настолько полезна, как хотелось бы, поскольку
она имеет смысл только для 32- и 64-битных значений. Вспомните, что при
вычислении выражений меньшие значения автоматически повышаются до
int. В итоге происходит расширение знака, и сдвиг будет выполняться над
32-битным, а не 8- или 16-битным значением. То есть можно ожидать, что
беззнаковый сдвиг вправо значения byte заполнит нулями, начиная с бита 7.
Но это не так, поскольку на самом деле сдвигается 32-битное значение.
* */
// Безэнаковый сдвиг вправо значения типа byte . стр 123
class ByteUShift {
    static public void main(String[] args) {
        char[] hex = {
                '0', '1', '2', '3', '4', '5', '6', '7',
                'В', '9', 'а', 'Ь', 'с', 'd', 'е', 'f'
        };

        byte b = (byte) 0xf1;
        byte c = (byte) (b >> 4);
        byte d = (byte) (b >>> 4);
        byte e = (byte) ((b & 0xff) >>> 4);
        System.out.println("                    Ь = Ох"
                + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
        System.out.println("               Ь >> 4 = Ох"
                + hex[(c >> 4) & 0x0f] + hex[c & 0x0f]);
        System.out.println("              Ь >>> 4 = Ох"
                + hex[(d >> 4) & 0x0f] + hex[d & 0x0f]);
        System.out.println("      (Ь & Oxff) >> 4 = Ох"
                + hex[(e >> 4) & 0x0f] + hex[e & 0x0f]);
    }
}
/*
* В  выводе программы  ByteUShift видно, что при работе с байтами
операция >>> ничего не делает. Для данной демонстрации переменной Ь при-
сваивается произвольное отрицательное значение типа byte. Затем пере-
менной с присваивается значение Ь типа byte, сдвинутое вправо на четы-
ре позиции, которое равно Oxff из-за ожидаемого расширения знака. Далее
переменной d присваивается значение Ь типа byte с беззнаковым сдвигом
вправо на четыре позиции, которым вопреки ожидаемому OxOf будет Oxff
по причине расширения знака, происшедшего при повышении Ь до int пе-
ред сдвигом. Последнее выражение устанавливает переменную е в значение
Ь типа byte, маскированное до 8 бит с помощью операции И, после чего
сдвинутое вправо на четыре позиции, что дает ожидаемое значение OxOf.
Обратите внимание, что операция беззнакового сдвига вправо не исполь-
зовался для переменной d, т.к. состояние знакового бита после операции И
было известно.
* */

/* стр 124
Все бинарные побитовые операции имеют составную форму, аналогичную
форме алгебраических операций, которая сочетает в себе присваивание с
побитовой операцией. Например, следующие два оператора, сдвигающие
значение вправо на четыре позиции, эквивалентны:
а = а >> 4 ;
а >>= 4

Аналогично два приведенных ниже оператора, присваивающие перемен-
ной а результат побитового выражения а ИЛИ Ь, тоже эквивалентны:
а = а | Ь ;
а 1 = Ь;

* В показанной далее программе создается несколько целочисленных
* переменных, с которыми затем осуществляются манипуляции с применением
* составных побитовых операций присваивания:
* */
class OpBitEquals {
    public static void main (String [] args) {
        int a = 1 ;
        int b = 2 ;
        int c = 3 ;
        a |= 4 ;
        b >>= 1 ;
        c <<= 1 ;
        a ^= c;
        System.out.println ("а = " + a ) ;
        System.out.println ("b = " + b ) ;
        System.out.println ("c = " + c ) ;
    }
}
