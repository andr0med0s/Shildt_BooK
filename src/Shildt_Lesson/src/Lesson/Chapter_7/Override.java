package Lesson.Chapter_7;

//стр 292 next

/*
 * Переопределение методов 
 * В иерархии  классов часто есть методы с одинаковой сигнатурой  и одинаковым возвращаемым значением, как в суперклассе, так и в подклассе. В этом случае  говорят,  что  метод  суперкласса переопределяется  в  подклассе.  Если переопределяемый метод вызывается из подкласса, то он всегда будет ссылаться на версию метода, определенную в подклассе. Версия метода, определенная в суперклассе, скрывается. Рассмотрим в качестве примера следующую программу.
 */

// Переопределение метода

// class A {

//   int i, j;

//   A(int a, int b) {
//     i = a;
//     j = b;
//   }

//   // Отображение переменных i и j
//   void show() {
//     System.out.println("i и j:  " + i + "  " + j);
//   }
// }

// class B extends A {

//   int k;

//   B (int a, int b, int c) {
//     super(a, b);
//     k = c;
//   }
//   void show() {                     //Метод show() в B переопределяет метод show() в A
//     System.out.println("k: " + k);
//   }
// }

//  class Override {
//   public static void main(String[] args) {
//     B subOb = new B (1,2,3);

//     subOb.show();
//   }
//  }

 /*
  * 
   Если метод show ()  вызывается для объекта типа в, выбирается версия этого метода, определенная в классе в.
  Таким образом, версия метода show ()  в классе В переопределяет версию одноименного метода, объявленную в классе А.

  Чтобы обратиться к исходной версии переопределяемого метода, т.е. к той, которая определена в суперклассе, следует воспользоваться ключевым словом super.

  Например,  в приведенном ниже варианте класса В из метода show ()
вызывается версия того же метода, определенная в суперклассе. При этом отображаются все переменные экземпляра.

class B extend A {
  int k;

  B(int a, int b, int c) {
    super { a, b};
    k = c;
  }

  void show () {
    super.show();  С помощью ключевого слова super вызывается версия метода show(), определенная в суперклассе A
        System.out.println("k: " + k);
  }
}  

       В данном случае su p e r. show ()  — это вызов метода show (), определенного в суперклассе.
  */

/**
 * Переопределение метода имеет место только в том случае, когда сигнатуры переопределяемого и переопределяющего методов совпадают. В противном случае происходит обычная перегрузка методов.  Рассмотрим следующую видоизмененную версию предыдущего примера.
 */


  class A {

    int i, j;
  
    A(int a, int b) {
      i = a;
      j = b;
    }
  
    // Отображение переменных i и j
    void show() {   // Поскольку сигнатуры разные, эта версия метода show() просто перезагружает метод show() в суперклассе A
      System.out.println("i и j:  " + i + "  " + j);
    }
  }
  

  // Создание подкласса путем расширения класса A
  class B extends A {
  
    int k;
  
    B (int a, int b, int c) {
      super(a, b);
      k = c;
    }

    // Перегрузка метода show()
    void show(String msg) {                     //Метод show() в B переопределяет метод show() в A
      System.out.println(msg + k);
    }
  }
  
   class Override {
    public static void main(String[] args) {
      B subOb = new B (1,2,3);
  
      subOb.show("k:  ");  // вызов метода show()  из класса В
      subOb.show();  // вызов метода show()  из класса А
    }
   }

   /**
    * На этот раз в версии метода show () из класса B предусмотрен строковый параметр.  
    Из-за этого сигнатура данного метода отличается от сигнатуры метода show ()  из класса А,
     для которого параметры не предусмотрены.
      Соответственно, никакого переопределения метода не происходит
    */
  