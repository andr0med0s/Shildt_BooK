// package Lesson.Chapter_7;

// /*
// Вызов super ()  позволяет использовать любую форму конструктора, определенную в суперклассе. В данном случае выбирается тот вариант конструктора, который соответствует указанным аргументам.  Ниже в качестве примера приведены расширенные версии классов TwoDShape и Triangle, которые содержат конструкторы, заданные по умолчанию, и конструкторы, имеющие один и более аргументов.
//  */

// // Добавление дополнительных конструкторов в класс TwoDShape

// class TwoDShape {

//   private double width; // теперь эти переменные
//   private double height; // объявлены как закрытые

//   //Конструктор,  заданный по умолчанию
//   TwoDShape() {
//     width = height = 0.0;
//   }

//   //Параметризированный конструктор
//   TwoDShape(double w, double h) { // конструктор класса TwoDShape
//     width = w;
//     height = h;
//   }

//   // Создание объекта с одинаковыми значениями
//   // переменных экземпляра width и height
//   TwoDShape(double х) {
//     width = height = х;
//   }

//   // Методы доступа к переменным экземпляра width и height
//   double getWidth() {
//     return width;
//   }

//   double getHeight() {
//     return height;
//   }

//   void setWidth(double w) {
//     width = w;
//   }

//   void setHeight(double h) {
//     height = h;
//   }

//   void showDim() {
//     System.out.println("Ширина и высота - " + width + " и " + height);
//   }
// }

// // Подкласс для представления треугольников,
// // производный от класса TwoDShape

// class Triangle extends TwoDShape {

//   private String style;

//   Triangle() {
//     super(); // вызов конструкора суперкласса по умолчанию
//     style = "none";
//     //Использование метода super() для вызова разных форм конструктора класса TwoDShape

//   }

//   //  вызов конструктора суперкласса с двумя аргументами
//   Triangle(String s, double w, double h) {
//     super(w, h); //
//     //Использование метода super() для вызова разных форм конструктора класса TwoDShape

//     style = s;
//   }

//   // вызов конструктора суперкласса с одним аргументом
//   Triangle(double х) {
//     super(х);
//     style = "закрашенный";
//   }

//   double area() {
//     return getWidth() * getHeight() / 2;
//   }

//   void showStyle() {
//     System.out.println("Треугольник " + style);
//   }
// }

// public class Shapes5 {

//   public static void main(String[] args) {
//     Triangle t1 = new Triangle();
//     Triangle t2 = new Triangle("контурный", 8.0, 12.0);
//     Triangle t3 = new Triangle(4.0);

//     t1 = t2;

//     System.out.println("Информация о t1:  ");
//     t1.showStyle();
//     t1.showDim();
//     System.out.println("Площадь  -  " + t1.area());
//     System.out.println();
//     System.out.println("Информация о t2:  ");
//     t2.showStyle();
//     t2.showDim();
//     System.out.println("Площадь  -  " + t2.area());

//     System.out.println();

//     System.out.println("Информация о t3:  ");
//     t3.showStyle();
//     t3.showDim();
//     System.out.println("Площадь -  " + t3.area());
//     System.out.println();
//   }
// }
// /*
// В конструкторе Triangle осуществляется вызов конструктора super ()  с параметрами w и h. Это приводит к тому, что управление получает конструктор TwoDShape (), инициализирующий переменные width и height данными значениями, благодаря чему класс Triangle не должен самостоятельно инициализировать элементы суперкласса.  Ему остается инициализировать только собственную переменную экземпляра style. Конструктору TwoDShape ()  предоставляется возможность создать соответствующий объект так, как требуется для данного класса.  Более того, в суперклассе TwoDShape можно реализовать функции, о которых подклассам ничего не будет известно.  Благодаря этому повышается степень отказоустойчивости кода
//  */

//  /*
//   * Еще раз напомним основные особенности вызова конструктора su p e r (). Если этот вызов присутствует в конструкторе подкласса, то происходит обращение к конструктору его непосредственного суперкласса. Таким образом, вызывается  конструктор того класса,  который непосредственно породил  вызывающий класс. Это справедливо и при многоуровневой иерархии.  Кроме того, вызов  конструктора su p e r ()  должен  быть первой  инструкцией  в теле  конструктора подкласса.
//   */