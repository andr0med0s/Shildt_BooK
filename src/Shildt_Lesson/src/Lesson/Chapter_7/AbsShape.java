package Lesson.Chapter_7;

/**
 * Глава 7. Наследование 301
 * 
 * Использование абстрактных классов
 * 
 * Иногда требуется создать суперкласс,  в котором определяется лишь самая 
 * общая форма для всех его подклассов, а наполнение ее деталями предоставляется
 *  каждому из этих подклассов. В таком классе определяется лишь суть методов, 
 * которые должны быть конкретно реализованы в подклассах, а не в самом суперклассе. 
 *  Подобная ситуация возникает, например, в связи с невозможностью полноценной
 *  реализации метода в суперклассе.  Именно такая ситуация была продемонстрирована
 *  в варианте класса TwoDShape из предыдущего примера, где метод area ()  был определен 
 * всего лишь как заполнитель. Такой метод не вычисляет и не выводит площадь двумерной 
 * геометрической формы любого типа.
 * 
 * Создавая  собственные библиотеки классов,  вы  сможете сами убедиться  в том,
 *  что ситуации, когда невозможно дать полное определение метода в контексте его суперкласса, 
 *  встречаются довольно часто.  Подобное затруднение разрешается двумя способами. 
 * Один из них, как было показано в предыдущем примере, состоит в том, чтобы просто 
 * вывести предупреждающее сообщение. И хотя в некоторых случаях, например при отладке,
 *  такой способ может быть действительно полезным,  в практике программирования он обычно не  применяется. 
 *  Ведь в суперклассе  могут быть объявлены  методы,  которые должны быть переопределены в подклассе, 
 * чтобы этот класс приобрел конкретный смысл.  Рассмотрим для примера класс Triangle. 
 * Он был бы неполным, если бы в нем не был переопределен метод area (). 
 *  В подобных случаях требуется какой-то способ, гарантирующий, что в подклассе действительно будут
 *  переопределены все необходимые методы. И такой способ имеется в Java: он состоит в использовании 
 * абстрактного метода.Абстрактный метод объявляется с использованием спецификации abstract. 
 * Абстрактный метод не имеет тела и потому не реализуется в суперклассе.
 *  Это означает, что он должен быть переопределен в подклассе, поскольку его вариант из суперкласса 
 * просто непригоден для использования. Для определения абстрактного метода используется следующий общий синтаксис:
 * 
 * abstract тип имя {список_парамвтров) ;
 * 
 * Как видите, в этом синтаксисе отсутствует тело. Спецификация abstract может применяться только к обычным методам,
 *  но не к статическим или конструкторам.
 * Класс, содержащий один или несколько абстрактных методов, должен быть также  объявлен  как  абстрактный 
 *  с  использованием  той  же  спецификации abstract  в объявлении класса.  Поскольку абстрактный класс
 *  не определяет реализацию полностью, у него не может быть объектов. Следовательно, попытка создать объект
 *  абстрактного класса с помощью оператора new приведет к появлению ошибки во время компиляции.


 Подкласс,  наследующий  абстрактный  класс,  должен  реализовать все  абстрактные  методы  суперкласса.
   В  противном  случае  он  также должен  быть определен как абстрактный. Таким образом, атрибут abstract 
   наследуется до тех пор, пока не будет достигнута полная реализация класса.
   
   Используя абстрактный класс, мы можем усовершенствовать рассмотренный ранее класс TwoDShape. 
   Для неопределенной двумерной геометрической фигуры понятие площади не имеет смысла,
    поэтому в приведенной ниже версии программы метод area ()  и сам класс TwoDShape объявляются как абстрактные.
     Это, конечно, означает, что любой класс, наследующий класс TwoDShape,должен переопределить метод area ().
 */

 //-----------------------

// Создание абстрактного класса
abstract class TwoDShape { // Класс TwoDshape теперь абстрактный

  private double width;
  private double height;
  private String name;

  //Конструктор по умолчанию
  TwoDShape() {
    width = height = 0.0;
    name = "none";
  }

  // Параметризированный конструктор
  TwoDShape(double w, double h, String n) {
    width = w;
    height = h;
    name = n;
  }

  // Создание объекта с одинаковыми значениями
  //переменных экземпляра width и height
  TwoDShape(double x, String n) {
    width = height = x;
    name = n;
  }

  // Создание одного объекта на основе другого
  TwoDShape(TwoDShape ob) {
    width = ob.width;
    height = ob.height;
    name = ob.name;
  }

  // Методы доступа к переменным width и height
  double getWidth() {
    return width;
  }

  double getHeight() {
    return height;
  }

  void setWidth(double w) {
    width = w;
  }

  void setHeight(double h) {
    height = h;
  }

  String getName() {
    return name;
  }

  void showDim() {
    System.out.println("Ширина и высота - " + width + " и " + height);
  }

  // Теперь метод area() абстрактный
  abstract double area(); // превращение area() в абстрактый метод
}

// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {

  private String style;

  // Конструктор по умолчанию
  Triangle() {
    super();
    style = "none";
  }

  //Конструктор класса Triangle
  Triangle(String s, double w, double h) {
    super(w, h, "треугольник");
    style = s;
  }

  //Конструктор с одним аргументом для построения треугольника
  Triangle(double w) {
    super(w, "треугольник"); // вызвать конструктор суперкласса
    style = "закрашенный";
  }

  // Создание одного объекта на основе другого
  Triangle (Triangle ob) {
    super(ob); // передача объекта конструктору класса TwoDshape
    style = ob.style;
  }

  double area (){
    return getWidth() * getHeight()/2;
  }
  void showStyle(){
    System.out.println("Треугольник " + style);
  }
}

// Подкласс для представления прямоугольников,
// производный от класса TwoDshape
class Rectangle extends TwoDShape {
  // Конструктор по умолчанию
  Rectangle(){
    super();
  }

  // Конструктор класса Rectangle
  Rectangle(double w, double h){
    super(w, h, "прямоугольник"); // вызвать конструктор супер класса
  }

  // Создание квадрата
  Rectangle(double x) {
    super(x, "прямоугольник"); // вызвать конструкор супер класса
  }

  //Создание одного объекта на основе другого
  Rectangle(Rectangle ob) {
    super(ob); // передача объекта конструктору класса TwoDShape
  }

  boolean isSquare(){
    if(getWidth() == getHeight()) return true;
    return false;
  }

  double area() {
    return getWidth() * getHeight();
  }
}

public class AbsShape {
  public static void main(String[] args) {
    TwoDShape shapes[] = new TwoDShape[4];

    shapes[0] = new Triangle("контурный", 8.0,12.0);
    shapes[1] = new Rectangle(10);
    shapes[2] = new Rectangle(10, 4);
    shapes[0] = new Triangle(7.0);

    for(int i = 0; i < shapes.length; i++) {
      System.out.println("Объект - " + shapes[i].getName());
      System.out.println("Площадь - " + shapes[i].area());
      System.out.println();
    }
  }
}

//-------------------------------
/**
 * Как видно из текста программы, все классы, наследующие класс TwoDShape,
 * должны переопределять метод area (). Вы можете убедиться в этом самостоятельно,
 *  попытавшись создать подкласс, в котором метод area ()  не переопределен.  
 * В итоге вы получите сообщение об ошибке во время компиляции. Разумеется, 
 * возможность создания объектной ссылки типа TwoDShape, что и было сделано
 *  в приведенном выше примере программы, у вас остается, но объявить объект 
 * типа TwoDShape вы уже не сможете. Именно поэтому массив shapes в методе main () 
 *  уменьшен до четырех элементов, а объект типа TwoDShape для абстрактной двумерной 
 * геометрической фигуры больше не создается.
 * 
 * И еще одно,  последнее замечание.  
 * Обратите внимание на то, что в классе TwoDShape по-прежнему определяются методы 
 * showDim ()  и getName ()  без модификатора abstract. Ничего предосудительного 
 * в этом нет, поскольку допускается  (и это часто используется на практике),
 *  чтобы абстрактные классы включали в себя конкретные методы,
 *  к которым подклассы могут обращаться в своем исходном коде.
 *  Переопределению в подклассах подлежат лишь те методы, которые объявлены как abstract.

 */