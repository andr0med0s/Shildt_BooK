package Lesson.Chapter_7;

/** Глава 7. Наследование 297
 * Демонстрация механизма переопределения
 * методов на примере класса TwoDShape
 */

/**
 * Для того чтобы стало понятнее, насколько эффективным является механизм переопределения методов, продемонстрируем его применение на примере класса TwoDShape. В приведенных ранее примерах в каждом классе, наследующем класс TwoDShape, определялся метод area (). Теперь мы знаем, что в этом случае имеет смысл включить метод area ()  в состав класса TwoDShape, позволить каждому его подклассу переопределить этот метод и, в частности, реализовать вычисление площади в зависимости от конкретного типа геометрической фигуры.  Именно такой подход и реализован в приведенном ниже примере программы. Для удобства в класс TwoDShape добавлено поле name. (Это упрощает написание демонстрационной программы.)
 */

// Использование динамической диспетчеризации методов
class TwoDShape {

  private double width;
  private double height;
  private String name;

  // Конструктор по умолчанию
  TwoDShape() {
    width = height = 0.0;
    name = "none";
  }

  // Параметризированный конструктор
  TwoDShape(double w, double h, String n) {
    width = w;
    height = h;
    name = n;
  }

  // Создание объекта с одинаковыми значениями
  // переменных экземпляра width и height
  TwoDShape(double х, String n) {
    width = height = х;
    name = n;
  }

  // Создание одного объекта на основе другого
  TwoDShape(TwoDShape ob) { //Конструирование объекта на основе другого объекта
    width = ob.width;
    height = ob.height;
    name = ob.name;
  }

  // Методы доступа к переменным экземпляра width и height
  double getWidth() {
    return width;
  }

  double getHeight() {
    return height;
  }

  void setWidth(double w) {
    width = w;
  }

  void setHeight(double h) {
    height = h;
  }

  String getName() {
    return name;
  }

  void showDim() {
    System.out.println("Ширина и высота - " + width + " и " + height);
  }

  double area() {
    System.out.println("Метод area() должен быть переопределен");
    return 0.0;
  }
}

// Подкласс,  применяемый для представления треугольников
//и производный от класса TwoDShape

class Triangle extends TwoDShape {

  private String style;

  // Конструктор по умолчанию
  Triangle() {
    super();
    style = "none";
  }

  // Конструктор класса Triangle
  Triangle(String s, double w, double h) {
    super(w, h, "треугольник"); // вызов конструктора суперкласса
    style = s;
  }

  // Конструктор с одним аргументом для построения треугольника
  Triangle(double х) {
    super(х, "треугольник"); // вызов конструктора суперкласса
    style = "закрашенный";
  }

  // Создание одного объекта на основе другого

  /*
   * В качестве параметра данному конструктору передается объект Triangle,
   * который затем с  помощью  вызова метода super ()  передается  конструктору
   * TwoDShape.
   */
  Triangle(Triangle ob) {
    super(ob); // передача объекта конструктору класса TwoDShape
    style = ob.style;
  }

  // Переопределение метода area()  для класса Triangle
  double area() {
    return getWidth() * getHeight() / 2; // Переопределение метода area()  для класса Triangle
  }

  void showStyle() {
    System.out.println("Треугольник " + style);
  }
}

// Подкласс для представления прямоугольников,
// производный от класса TwoDShape

class Rectangle extends TwoDShape {

  // Конструктор по умолчанию
  Rectangle() {
    super();
  }

  // Конструктор класса Rectangle
  Rectangle(double w, double h) {
    super(w, h, "прямоугольник"); // вызов конструктора суперкласса
  }

  // Создание квадрата
  Rectangle(double х) {
    super(х, "прямоугольник"); // вызов конструктора суперкласса
  }

  // Создание одного объекта на основе другого
  Rectangle(Rectangle ob) {
    super(ob); // передача объекта конструктору класса TwoDShape
  }

  boolean isSquare() {
    if (getWidth() == getHeight()) return true;
    return false;
  }

  // Переопределение метода area()  для класса Rectangle
  double area() { // Переопределение метода area()  для класса Rectangle
    return getWidth() * getHeight();
  }
}

public class DynShapes {

  public static void main(String[] args) {
    TwoDShape shapes[] = new TwoDShape[5];
    shapes[0] = new Triangle("контурный", 8.0, 12.0);
    shapes[1] = new Rectangle(10);
    shapes[2] = new Rectangle(10, 4);
    shapes[3] = new Triangle(7.0);
    shapes[4] = new TwoDShape(10, 20, "фигура");

    for (int i = 0; i < shapes.length; i++) {
      System.out.println("Объект -  " + shapes[i].getName());
      System.out.println("Площадь  -  " + shapes[i].area());
      System.out.println();
    }
  }
}


/**
 * стр 300
 * 
 * Рассмотрим  код данной  программы более  подробно.  Теперь,  как и  предполагалось при  написании  программы,  метод area ()  входит в состав  класса TwoDShape и переопределяется в классах Triangle и Rectangle. В классе TwoDShape метод area ()  играет роль заполнителя и лишь уведомляет пользователя о том, что этот метод должен быть переопределен в подклассе. При каждом переопределении метода area ()  в нем реализуются средства, необходимые для того типа объекта, который инкапсулируется в подклассе. Так, если требуется реализовать класс для эллипсов, метод area ()  придется переопределить таким образом, чтобы он вычислял площадь этой фигуры.
 * 
 * Рассматриваемая  здесь  программа  имеет еще  одну  важную особенность. Обратите внимание на то, что в методе main ()  геометрические фигуры объявляются как массив объектов типа TwoDShape. Но на самом деле элементами массива являются ссылки на объекты Triangle, Rectangle и TwoDShape. Это вполне допустимо.  Ведь, как пояснялось ранее, ссылочная переменная суперкласса может ссылаться на объект его подкласса.  В этой программе организован перебор элементов массива в цикле и вывод сведений о каждом объекте. 
 * Несмотря на всю простоту данного примера, он наглядно демонстрирует потенциальные возможности как наследования классов, так и переопределения методов.
 *  Тип объекта, на который указывает ссылочная переменная суперкласса, определяется во время выполнения, что гарантирует правильный выбор версии переопределенного метода.  Если объект является производным от класса TwoDShape, то для вычисления его площади достаточно вызвать метод area ().Интерфейс для выполнения данной операции оказывается общим и не зависит от того, с какой именно геометрической фигурой приходится иметь дело.

 */