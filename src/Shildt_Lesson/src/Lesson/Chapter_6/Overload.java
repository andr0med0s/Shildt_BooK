package Shildt_Lesson.src.Lesson.Chapter_6;
//------------стр 234

/*
* Несколько методов одного класса могут иметь одно
и то же имя, отличаясь лишь набором параметров. Подобные методы
* называются перегруженными, а сам процесс называют перегрузкой методов.
* */
/*
* Для того чтобы перегрузить метод, достаточно объявить его новый вариант,
который отличается от уже существующих, а все остальное сделает за вас
* компилятор. Нужно лишь соблюсти одно условие: тип и/или число параметров в
каждом из перегружаемых методов должны быть разными. Одного лишь различия
*  в типах возвращаемых значений для этой цели недостаточно.
* (Информации о возвращаемом типе не всегда будет хватать Java для
*  принятия решения о том, какой именно метод должен использоваться.)
*  Конечно, перегружаемые методы могут иметь разные возвращаемые типы,
*  но при вызове метода выполняется лишь тот его вариант, в котором
*  параметры соответствуют передаваемым аргументам.
* */
// Перегрузка методов
class Overload {
    void ovlDemo() { //------ Первая версия
        System.out.println("Без параметров");
    }
    /*
    int ovlDemo(int а) { //Возвращаемое значение нельзя использовать для различения
    System.out.println("Один параметр: " + a);             // перегружаемых методов
    return a * a;
    }
    * */

    // Перегрузка метода ovlDemo для одного параметра типа int
    void ovlDemo(int a) { //------ Вторая версия
        System.out.println("Один параметр: " + a);
    }

    // Перегрузка метода ovlDemo для двух параметров типа int
    int ovlDemo(int a, int b) { //------ третья  версия
        System.out.println("Два параметра: " + a + " " + b);
        return a + b;
    }

    // Перегрузка метода ovlDemo для двух параметров типа double
    double ovlDemo(double a, double b) { //------ четвертая  версия
        System.out.println("Два параметра типа double : " + a + " " + b);
        return a + b;
    }
}

class OverloadDemo {
    public static void main(String[] args) {
        Overload ob = new Overload();
        int resl;
        double resD;
// Поочередный вызов всех версий метода ovlDemo()
        ob.ovlDemo();
        System.out.println();
        ob.ovlDemo(2);
        System.out.println();
        resl = ob.ovlDemo(4, 6);
        System.out.println("Результат вызова ob.ovlDemo(4, 6): " + resl);
        System.out.println();
        resD = ob.ovlDemo(1.1, 2.32);
        System.out.println("Результат вызова ob.ovlDemo(1.1, 2.32): " + resD);
    }
}
//Обратите внимание на то, что первые два варианта метода
//ovlDemo () имеют тип void, а два других возвращают значение.

//тип возвращаемого значения не учитывается при перегрузке методов.!!!!!

//в Java применяется автоматическое приведение типов,
// которое распространяется и на типы параметров перегружаемых методов.


// стр 236
/* Автоматическое преобразование типов может влиять
на выбор перегружаемого метода.
*/
class Overload2 {
    void f(int x) {
        System.out.println("Внутри f(int): " + x);
    }

    void f(double x) {
        System.out.println("Внутри f(double): " + x);
    }
}

class TypeConv {
    public static void main(String[] args) {
        Overload2 ob = new Overload2();
        int i = 10;
        double d = 10.1;
        byte b = 99;
        short s = 10;
        float f = 11.5F;
        ob.f(i);// вызов метода ob.f(int)
        ob.f(d);// вызов метода ob.f(double)

        ob.f(b); // вызов метода ob.f(int) с преобразованием типов
        ob.f(s); // вызов метода ob.f(int) с преобразованием типов
        ob.f(f); // вызов метода ob.f(double) с преобразованием типов
    }
}
/*
* В данном примере определены только два варианта метода f(): один имеет
*  параметр типа int, а второй — параметр типа double. Но передать методу
f() можно также значение типа byte, short и float. Значения типа byte и
short исполняющая среда Java автоматически преобразует в тип int. В резуль-
тате будет вызван вариант метода f(int). А если параметр имеет значение типа
float, то оно преобразуется в тип double, и далее вызывается вариант метода
f(double).
* */

//!!!!!!Важно понимать, что автоматическое преобразование типов выполняется
//лишь в отсутствие прямого соответствия типов параметра и аргумента.!!

//стр 237
// Добавление версии метода f(byte)
class Overload3 {
    void f (byte x) { //<  Эта версия имеет----- параметр типа byte-----
            System.out.println( "Внутри f(byte): " + x ) ;
    }

    void f(int x) {
        System.out.println("Внутри f(int): " + x);
    }

    void f(double x) {
        System.out.println("Внутри f(double): " + x);
    }
}
class TypeConv1 {
    public static void main(String[] args) {
        Overload3 ob = new Overload3();
        int i = 10;
        double d = 10.1;
        byte b = 99;
        short s = 10;
        float f = 11.5F;
        ob.f(i); // вызов метода ob.f(int)
        ob.f(d); // вызов метода ob.f(double)
        ob.f(b); // вызов метода ob.f(byte) без преобразования типов
        ob.f(s); // вызов метода ob.f(int) с преобразованием типов
        ob.f(f); // вызов метода ob.f(double) c преобразованием типов
    }
}
/*
* Поскольку в данной программе предусмотрена версия метода f(), которая
имеет параметр типа byte, то при вызове этого метода с аргументом типа byte
выполняется вызов f(byte), и тип byte автоматически не преобразуется в тип int
*
* Перегрузка методов поддерживает полиморфизм, поскольку она является
одним из способов реализации парадигмы “один интерфейс — множество методов”.
*
* Главная ценность перегрузки заключается в том, что она обеспечивает до-
ступ к группе родственных методов по общему имени. Следовательно, имя abs
обозначает общее выполняемое действие, а компилятор сам выбирает конкретный
вариант метода, исходя из имеющихся обстоятельств. Благодаря полиморфизму
несколько имен сводятся к одному.
*
* */

// На практике перегружать следует только тесно связанные операции

/*
*       Java сигнатура обозначает имя метода и список его параметров.
*  При перегрузке методов действует следующее правило: никакие
два метода из одного класса не могут иметь одинаковые сигнатуры. При этом
следует иметь в виду, что сигнатура не включает в себя тип возвращаемого
значения, поскольку он не используется в Java при принятии решения о
*  перегрузке.
* */