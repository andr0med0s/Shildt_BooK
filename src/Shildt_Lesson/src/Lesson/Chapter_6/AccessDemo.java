package Lesson.Chapter_6;

// Сравнение модификаторов доступа public и private
//стр 223
class MyClass {
    private int alpha; //закрытый доступ
    public int beta; //открытый доступ
    int gamma; //тип доступа по умолчанию (по сути, public)

    // Методы доступа к переменной alpha. Члены класса могут
    // обращаться к закрытым членам того же класса,
    void setAlpha(int а) {
        alpha = а;
    }

    int getAlpha() {
        return alpha;
    }
}

class AccessDemo {
    public static void main(String[] args) {
        MyClass ob = new MyClass();

        // Доступ к переменной alpha возможен только с помощью
        // специально предназначенных для этой цели методов
        ob.setAlpha(-99);
        System.out.println("ob.alpha: " + ob.getAlpha());

        // Обращение к переменной alpha так, как показано ниже,
        // недопустимо
        // ob.alpha = 10; // Ошибка: alpha - закрытая переменная!

        // Следующие обращения вполне допустимы, так как
        // переменные beta и gamma являются открытыми
        ob.beta = 88;
        ob.gamma = 99;
    }
}
//------------------стр 225------------------
/* В этом классе реализуется "отказоустойчивый" массив,
предотвращающий ошибки времени выполнения
*/

class FailSoftArray {
    private int[] a; // ссылка на массив
    private int errval;// значение, возвращаемое в случае возникновения
    // ошибки при выполнении метода get()
    public int length;// открытая переменная length

    // Конструктору данного класса передаются размер массива
    //и значение, которое должен возвращать метод get() при
    // возникновении ошибки
    public FailSoftArray(int size, int errv) {
        a = new int[size];
        errval = errv;
        length = size;
    }

    // Возврат значения элемента массива с заданным индексом
    public int get(int index) {
        if (indexOK(index)) return a[index]; //----отслеживание попытки выхода за пределы массива
        return errval;
    }

    // Установка значения элемента с заданным индексом.
    // Если возникнет ошибка, вернуть логическое значение false,
    public boolean put(int index, int val) {
        if (indexOK(index)) { //----отслеживание попытки выхода за пределы массива
            a[index] = val;
            return true;
        }
        return false;
    }

    // Возврат логического значения true, если индекс
    // не выходит за пределы массива
    private boolean indexOK(int index) {
        if (index >= 0 & index < length) return true;
        return false;
    }
}

// Демонстрация работы с "отказоустойчивым" массивом
class FSDemo {
    public static void main(String[] args) {
        FailSoftArray fs = new FailSoftArray(5, -1);
        int x;

        // Демонстрация корректной обработки ошибок
        System.out.println("Обработка ошибок без вывода отчета.");
        for (int i = 0; i < (fs.length * 2); i++)
            fs.put(i, i * 10);   // Для обращения к элементам массива должны использоваться
        //его методы доступа
        for (int i = 0; i < (fs.length * 2); i++) {
            x = fs.get(i);          // Для обращения к элементам массива должны использоваться
            //его методы доступа
            if (x != -1) System.out.print(x + " ");
        }
        System.out.println("");

        // Обработка ошибок
        System.out.println("\nОбработка ошибок с выводом отчета.");
        for (int i = 0; i < (fs.length * 2); i++)
            if (!fs.put(i, i * 10))
                System.out.println("Индекс " + i + " вне допустимого диапазона");
        for (int i = 0; i < (fs.length * 2); i++) {
            x = fs.get(i);
            if (x != -1) System.out.print(x + " ");
            else
                System.out.println("Индекс " + i + " вне допустимого диапазона");
        }
    }
}
/*
* В классе FailSoftArray определены три закрытых члена.
*  Первым из них является переменная а, в которой содержится ссылка на
* массив, предназначенный для хранения данных.
*  Вторым членом является переменная errval, в которой хранится значение,
*  возвращаемое вызывающей части программы
*  в том случае, если вызов метода get()приводит к ошибке.
*  И третьим членом является метод indexOk(), в котором определяется,
* находится ли индекс в допустимых пределах.
*  Эти три члена могут быть использованы только другими членами класса
*  FailSoftArray.
*  Остальные члены данного класса объявлены открытыми и могут быть вызваны
* из любой части программы,
*  в которой используется класс FailSoftArray.
*   При создании объекта типа FailSoftArray следует указать размер массива
и значение, которое должно возвращаться в случае неудачного вызова метода
get (). Это значение не может совпадать ни с одним значением, хранящимся в
массиве. После создания объекта непосредственный доступ извне его к масси-
ву, на который указывает ссылка, хранящаяся в переменной а, а также к пере-
менной errval невозможен, что исключает их некорректное использование.
В частности, пользователь не сможет непосредственно обратиться к массиву по
ссылке в переменной а, задав индекс элемента, выходящий за границы допу-
стимого диапазона. Доступ к указанным элементам возможен только с помо-
щью методов get () и put ().
Метод indexOK () объявлен как закрытый главным образом для того, что-
бы продемонстрировать управление доступом. Но даже если бы он был от-
крытым, то это не создавало бы никакого риска, поскольку он не видоизменя-
ет объект. Однако, поскольку этот метод используется только членами класса
FailSoftArray, он объявлен закрытым.
Обратите внимание на то, что переменная экземпляра length открыта. Это
согласуется с правилами реализации массивов в Java. Для того чтобы получить
данные о длине массива типа FailSoftArray, достаточно прочитать значение
переменной экземпляра length.
Для сохранения данных в массиве типа FailSoftArray по указанному ин-
дексу вызывается метод put (), тогда как метод get () извлекает содержимое
элемента этого массива по заданному индексу. Если индекс оказывается вне
границ массива, то метод put () возвращает логическое значение false, а ме-
тод get () — значение errval.
* */

//-----очень важно ограничивать доступ к членам класса и в особенности к переменным.---!!!!


//----------Полное руководство стр 198
/* В этой программе демонстрируется отличие между pubic и private. */

class Test {
    int a;          //стандартный доступ
    public int b;   //открытый доступ
    private int c;  //закрытый доступ

    //методы для доступа к с
    void setc(int i) {  // установить значения с
        c = i;
    }

    int getc() {         // получить значения с
        return c;
    }
}

class AcessTest {
    public static void main(String[] args) {
        Test ob = new Test();

        ob.a = 10;
        ob.b = 20;

        //  ob.c = 100; возникает ошибка
        //получить доступ к члену с  необходимо через его методы
        ob.setc(100);
        System.out.println("a, b и c: " + ob.a + " " + ob.b + " " + ob.getc());
    }
}

//-----------------
// Этот класс реализует стек целых чисел, который может хранить 10 значений
class Stack {
    /* Теперь stck и tos являются закрытым . Это значит,
        что они не могут быть случайно или злонамеренно
        изменены таким образом, что может повредиться стек.
    */
    private int[] stck = new int[10];
    private int tos;

    // Инициализировать верхушку стека.
    Stack() {
        tos = -1;
    }

    // Поместить элемент в стек.
    void push(int item) {
        if (tos == 9) {
            System.out.println("Cтeк полон. ");
        } else {
            stck[++tos] = item;
        }
    }

    // Извлечь элемент из стека.
    int рор() {
        if (tos < 0) {
            System.out.println("Cтeк опустошен. ");
            return 0;
        } else {
            return stck[tos--];
        }
    }
}
//стр 199 полное руководство
class TestStack {
    public static void main(String[] args) {
        Stack mystack1 = new Stack();
        Stack mystack2 = new Stack();
//Поместить несколько чисел в стеки.
        for (int i = 0; i < 10; i++) mystack1.push(i);
        for (int i = 10; i < 20; i++) mystack2.push(i);
//Извлечь эти числа из стеков.
        System.out.println("Cтeк в mystack1 : ");
        for (int i = 0; i < 10;
             i++)
            System.out.print(mystack1.рор());
        System.out.println("Cтeк в mystack2 : ");
        for (int i = 0; i < 10; i++)
            System.out.println(mystack2.рор());
//Приведенные далее операторы являются недопустимыми.
        //mystack1.tos = -2;
        //mystack2.stck[З] = 100;
    }
}