package Lesson.Chapter_6;
// стр 248
// Применение статической переменной

class StaticDemo {
    int x; //--- обычная переменная экземпляра
    static int y; // --- статическая переменная //--Все объекты используют одну и ту

    // же копию статической переменной
    //Возврат суммы значений переменной экземпляра x и статической переменной y
    int sum() {
        return x + y;
    }
}

class SDemo {
    public static void main(String[] args) {
        StaticDemo ob1 = new StaticDemo();
        StaticDemo ob2 = new StaticDemo();
        // У каждого объекта имеется своя копия переменной экземпляра
        ob1.x = 10;
        ob2.x = 20;
        System.out.println("Разумеется, ob1.x и ob2.x " + "независимы");
        System.out.println("obi.x: " + ob1.x + "\nob2.x: " + ob2.x);
        System.out.println();

        // Все объекты совместно используют одну общую копию статической переменной
        System.out.println("Статическая переменная у - общая");
        StaticDemo.y = 19;
        System.out.println("Присвоить StaticDemo.у значение 19");
        System.out.println("ob1.sum(): " + ob1.sum());
        System.out.println("ob2.sum(): " + ob2.sum());
        System.out.println();

        StaticDemo.y = 100;
        System.out.println("Изменить значение StaticDemo.y на 100");
        System.out.println("ob1.sum() : " + ob1.sum());
        System.out.println("ob2.sum(): " + ob2.sum());
        System.out.println();
    }
}
/*
 * Нетрудно заметить, что статическая переменная у используется как объектом
 *  оb1, так и объектом оЬ2. Изменения в ней оказывают влияние на весь класс,
 *  а не только на его экземпляр.*/

//стр 249
/*
Метод типа static отличается от обычного метода тем, что его можно вызывать
* по имени его класса, не создавая экземпляр объекта этого класса.
* */
//Применение статического метода
class StaticMeth {
    static int val = 1024; // статическая переменная

    //Статический метод
    static int valDiv2() {
        return val / 2;
    }
}

class SDemo2 {
    public static void main(String[] args) {

        System.out.println("Значение val: " + StaticMeth.val);
        System.out.println("StaticMeth.valDiv2(): " + StaticMeth.valDiv2());
        StaticMeth.val = 4;
        System.out.println("Значение val: " + StaticMeth.val);
        System.out.println("StaticMeth.valDiv2(): " + StaticMeth.valDiv2());
    }
}
/*
* На применение методов типа static накладывается ряд следующих ограничений:
в методе типа static допускается непосредственный вызов только других
методов типа static;
для метода типа static непосредственно доступными оказываются только
другие данные типа static, определенные в его классе;
в методе типа static должна отсутствовать ссылка this .
*
*
            * class StaticError {
            int denom =3; // обычная переменная экземпляра
            static int val = 1024; // статическая переменная
            *
            // Ошибка! К нестатическим переменным нельзя обращаться
            // из статического метода,
            static int valDivDenom() {
            return val/denom; // не пройдет компиляцию!
}
* В данном примере denom является обычной переменной экземпляра, к которой
*  нельзя обращаться из статического метода.
* */


/*   стр 251
* Статический блок выполняется при первой загрузке класса,
*  еще до того, как класс будет использован для каких-нибудь
    других целей.
* */

// Применение статического блока
class StaticBlock {
    static double rootOf2;
    static double rootOf3;

    static { //--этот блок выполняется при загрузке класса
        System.out.println("Внутри статического блока");
        rootOf2 = Math.sqrt(2.0);
        rootOf3 = Math.sqrt(3.0);
    }

    StaticBlock(String msg) {
        System.out.println(msg);
    }
}

class Sdemo3 {
    public static void main(String[] args) {
        // StaticBlock ob = new StaticBlock("Внутри конструктора");

        System.out.println("Корень квадратный из 2 равен " + StaticBlock.rootOf2);
        System.out.println("Корень квадратный из 3 равен " + StaticBlock.rootOf3);
    }
}
/*
* статический блок выполняется еще до того, как будет создан какой-либо объект.
* */


// стр 200 Полное руководство
// Ключевое слово static

/*
* Временами вам понадобится определять член класса, который будет при-
меняться независимо от любого объекта данного класса. Обычно доступ
к члену класса должен осуществляться только в сочетании с объектом его
класса. Однако можно создать член, который можно использовать сам по
себе, без привязки к конкретному экземпляру. Чтобы создать такой элемент,
перед его объявлением следует указать ключевое слово static (статический).
Когда член объявляется статическим, к нему можно получать доступ до того,
как будут созданы какие-либо объекты его класса, и без ссылки на какой-
либо объект. Объявить статическими можно как методы, так и переменные.
Наиболее распространенным примером статического члена является метод
main(), который объявлен как static, потому что он должен быть вызван до
того, как будут созданы любые объекты.
* */

/*
* Переменные экземпляра, объявленные как static, по существу являются
глобальными переменными. При объявлении объектов такого класса копия
статической переменной не создается. Взамен все экземпляры класса имеют
дело с одной и той же статической переменной.
С методами, объявленными как static, связано несколько ограничений.
*
• Они могут напрямую вызывать только другие статические методы своего класса.
*
• Они могут напрямую получать доступ только к статическим переменным своего класса.
*
• Они никоим образом не могут ссылаться на this или super.
*
Если для инициализации статических переменных нужно выполнять вычисления,
* тогда можно объявить блок static, который выполняется в точности один раз,
* когда класс загружается впервые.
* */

// Демонстрация применения статических переменных, методов и блоков.
class UseStatic {
    static int a = 3;
    static int b;

    static  void meth(int x) {
        System.out.println("x= " + x);
        System.out.println("a= " + a);
        System.out.println("b= " + b);
    }
    static {
        System.out.println("Инициализация в статическом блоке.");
        b = a * 4;
    }

    public static void main(String[] args) {
        meth(42);
    }
}
/*
* Сразу после загрузки класса UseStatic запускаются все статические операторы.
*  Сначала а устанавливается в 3, затем выполняется блок static, который выводит
*  сообщение, после чеrо b инициализируется значением а* 4, или 12. Далее вызывается
*  метод main(), который вызывает meth(), передавая в х значение 42.
* */

/*
* За пределами класса, в котором они определены, статические методы и
переменные могут использоваться независимо от любого объекта. Для этого
понадобится только указать имя их класса и за ним операцию точки. Скажем,
если вы хотите вызвать статический метод вне его класса, то можете применить
* следующую общую форму:

* имя-класса.метод()
*
Здесь в имя-класса указывается имя класса, rде объявлен статический метод.
*  Как видите, формат аналогичен тому, который используется для вызова
нестатических методов через переменные ссылок на объекты. Доступ к статической
*  переменной можно получить тем же способом - с помощью операции точки после
*  имени класса. Именно так в Java реализована управляемая версия глобальных
* методов и глобальных переменных.
* */

class StaticDemo1 {
    static  int a = 42;
    static  int b = 99;

    static void callme(){
        System.out.println("a = " + a);
    }
    class  StaticByName{
        public static void main(String[] args) {
            StaticDemo1.callme();
            System.out.println("b = " + StaticDemo1.b);
        }
    }
}

// стр 202 Ключевое слово final Полное руководство
/*
* Поле может быть объявлено как final(финальное), что предотвращает
* изменение его содержимого, делая его по существу константой. Это
* означает, что поле final должно быть инициализировано при его объявлении.
* Существует два способа инициализации такого поля.
* Во-первых, полю final можно присвоить значение при его объявлении.
* Во-вторых, полю final можно присвоить значение в конструкторе.
*
* Помимо полей как final могут быть объявлены и параметры метода, и
* локальные переменные. Объявление параметра как final предотвращает
* его изменение внутри метода. Объявление локальной переменой как final
* предотвращает присваивание ей значения более одного раза
* */
