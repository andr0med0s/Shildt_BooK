package Lesson.Chapter_6;


/*
* Вложенным называется такой класс,
* который объявляется в другом классе. Вложенные
* классы не относятся к базовым языковым средствам Java.
*
* Вложенный класс не может существовать независимо от класса, в который
он вложен. Следовательно, область действия вложенного класса ограничена его
внешним классом. Если вложенный класс объявлен в пределах области действия
внешнего класса, то он становится членом последнего. Имеется также возмож-
ность объявить вложенный класс, который станет локальным в пределах блока.
*
* Существуют два типа вложенных классов. Одни вложенные классы объяв-
ляются с помощью модификатора доступа static, а другие — без него.
*
* Внутренний класс имеет доступ ко всем переменным и методам внешнего
* класса, в который он вложен, и может обращаться к ним непосредственно,
* как и все остальные нестатические члены внешнего класса.
*  */
// Применение внутреннего класса
class Outer {
    int[] nums;

    Outer(int[] n) {
        nums = n;
    }

    void Analyze() {
        Inner inOb = new Inner();

        System.out.println("Минимум: " + inOb.min());
        System.out.println("Максимум: " + inOb.max());
        System.out.println("Среднее: " + inOb.avg());
    }

    //Внутренний класс
    class Inner { // --- внутренний класс
        int min() {
            int m = nums[0];

            for (int i = 1; i < nums.length; i++)
                if (nums[i] < m) m = nums[i];
            return m;
        }

        int max() {
            int m = nums[0];
            for (int i = 1; i < nums.length; i++)
                if (nums[i] > m) m = nums[i];
            return m;
        }

        int avg() {
            int a = 0;
            for (int i = 0; i < nums.length; i++)
                a += nums[i];
            return a / nums.length;
        }
    }
}


class NestedClassDemo {
    public static void main(String[] args) {
        int x[] = {3, 2, 1, 5, 6, 9, 7, 8};
        Outer outOb = new Outer(x);
        outOb.Analyze();
    }
}
/*
* В данном примере внутренний класс inner обрабатывает массив nums, яв-
ляющийся членом класса Outer. Вложенный класс имеет доступ к членам ох-
ватывающего класса и поэтому может непосредственно обращаться к массиву
nums. А вот обратное не справедливо. Так, например, метод analyze() не мо-
жет непосредственно вызвать метод min(), не создав объект типа inner.
* */

/*
 * стр 256 руководятво для начинающих
 * */
//// Применение класса ShowBits в качестве локального (упражнении 5.3)

class LocalClassDemo {
    public static void main(String[] args) {

        //Внутренняя версия класса ShowBits
        class ShowBits {   //◄ ----------------------- Локальный класс, вложенный в метод
            int numbits;

            ShowBits(int n) {
                numbits = n;
            }

            void show(long val) {
                long mask = 1;
// Сдвиг влево для установки единицы в нужной позиции
                mask <<= numbits - 1;
                int spacer = 0;
                for (; mask != 0; mask >>>= 1) {
                    if ((val & mask) != 0) System.out.print("1");
                    else System.out.print("0");
                    spacer++;
                    if ((spacer % 8) == 0) {
                        System.out.print(" ");
                        spacer = 0;
                    }
                }
                System.out.println();
            }
        }
        for (byte b = 0; b < 10; b++) {
            ShowBits byteval = new ShowBits(8);
            System.out.print(b + " в двоичном представлении: ");
            byteval.show(b);
        }
    }
}
/*
* В данном примере класс ShowBits недоступен за пределами метода main(),
а следовательно, попытка получить доступ к нему из любого метода, кроме
main(), приведет к ошибке.
И последнее замечание: внутренний класс может быть безымянным. Экзем-
пляр анонимного внутреннего класса создается при объявлении класса с помо-
щью оператора new.
* */
/*
Чем статический вложенный класс отличается от нестатического?

* Статический вложенный класс объявляется с помощью модификатора
static. Являясь статическим, он может непосредственно обращаться к лю-
бому статическому члену своего внешнего класса. Другие члены внешнего
класса доступны ему посредством ссылки на объект.
* */

//стр 204 Полное руководство
// -------------Вложенные и внутренние классы----------

/*
* Класс можно определять внутри другого класса; такой класс известен как
вложенный класс. Область действия вложенного класса ограничена областью
действия его объемлющего класса. Таким образом, если класс В определен
внутри класса А, то В не существует независимо от А. Вложенный класс имеет
доступ к членам, в том числе закрытым, класса, в который он вложен. Тем
не менее, объемлющий класс не имеет доступа к членам вложенного класса.
Вложенный класс, объявленный непосредственно в области действия его
объемлющего класса, будет членом объемлющего класса. Также можно объявлять
* вложенный класс, локальный для блока.
*
* Существуют два типа вложенных классов: статические и нестатические.
Статический вложенный класс - это класс, к которому применяется моди-
фикатор static. Поскольку класс статический, он должен обращаться к не-
статическим членам объемлющего класса через объект. То есть статический
вложенный класс не может напрямую ссылаться на нестатические члены объ-
емлющего класса
*
* Вторым типом вложенного класса является внутренний класс. Внутренний
класс - это нестатический вложенный класс. Он имеет доступ ко всем пере-
менным и методам своего внешнего класса и может ссылаться на них напря-
мую так же, как поступают другие нестатические члены внешнего класса.
* */

//Демонстрация работы с внутренним классом
class Outer1 {
    int outer_x = 100;

    void test() {
        Inner inner = new Inner();
        inner.display();
    }

    class Inner {
        void display() {
            System.out.println("display(): outer_x = " + outer_x);
        }
    }
}

class InnerClassDemo {
    public static void main(String[] args) {
        Outer1 outer = new Outer1();
        outer.test();
    }
}
/*
* В программе внутренний класс по имени Inner определен в рамках области
*  действия класса Outer, поэтому любой код класса Inner может напрямую
*  обращаться к переменной external_x. В классе Inner определен метод
*  экземпляра display() , который отображает external_х в стандартном
потоке вывода. Метод main() объекта InnerClassDemo создает экземпляр
класса Outer и вызывает его метод test(), который создает экземпляр класса
* Inner и вызывает метод display().
*
* !!!!!!!!!
* Важно понимать, что экземпляр Inner может быть создан только в контексте
*  класса Outer.
* */

/*
* Ранее уже объяснялось, что внутренний класс имеет доступ ко всем членам
*  окружающего его класса, но обратное неверно. Члены внутреннего класса
*  известны только в рамках области действия внутреннего класса и не могут
использоваться внешним классом.
* */

// Эта программа не скомпилируется .
class Outer2 {
    int outer_х = 100;

    void test() {
        Inner inner = new Inner();
        inner.display();
    }

    // Внутренний класс .
    class Inner {
        int у = 10; // переменная у является локальной для Inner

        void display() {
            System.out.println("display ( ) : outer х = " + outer_х);
        }
    }
/*
    void showy() {
        System.out.println(y); // ошибка, переменная у здесь неизвестна !
    }
    Здесь у объявлена как переменная экземпляра Inner. Таким образом, за
пределами этого класса она не известна и не может использоваться в методе
showy()
*/
}

class InnerClassDemo1 {
    public static void main(String[] args) {
        Outer2 outer = new Outer2();
        outer.test();
    }
}
/*
 * внутренние классы можно определять в рамках области действия любого блока.
 *  Скажем, вложенный класс можно определить в блоке, который определяется
 * методом, или даже в теле цикла for
 * */

// стр 206 полное руководство
// Определение внутреннего класса в пределах цикла for.
class Outer3 {
    int outer_x = 100;

    void test() {
        for (int i = 0; i < 10; i++) {
            class Inner {
                void display() {
                    System.out.println("display(): outer_x = " + outer_x);
                }
            }
            Inner inner = new Inner();
            inner.display();
        }
    }
}

class InnerClassDemo2 {
    public static void main(String[] args) {
        Outer3 outer = new Outer3();
        outer.test();
    }
}