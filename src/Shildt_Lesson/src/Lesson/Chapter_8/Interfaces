323 Java: руководство для начинающих, 7-е издание
Интерфейсы
Иногда в объектно-ориентированном программировании полезно определить, что именно должен делать 
класс, но не то, как он должен это делать. Примером может служить упоминавшийся ранее абстрактный 
метод. В абстрактном методе определяются возвращаемый тип и сигнатура метода, но не 
предоставляется его реализация. А в подклассе должна быть обеспечена своя собственная реализация 
каждого абстрактного метода, определенного в его суперклассе. Таким образом, абстрактный метод 
определяет интерфейс, но не реализацию метода. Конечно, абстрактные классы и методы приносят 
известную пользу, но положенный в их основу принцип может быть развит далее.  В Java предусмотрено 
разделение интерфейса класса и его реализации с помощью ключевого слова interface.

С точки зрения синтаксиса интерфейсы подобны абстрактным классам. Но в интерфейсе ни у одного из 
методов не должно быть тела. Это означает, что в интерфейсе вообще не предоставляется никакой 
реализации. В нем указывается только, что именно следует делать, но не как это делать.  Как только 
интерфейс будет определен, он может быть реализован в любом количестве классов. Кроме того, в 
одном классе может быть реализовано любое количество интерфейсов.

Для  реализации  интерфейса  в  классе  должны  быть  предоставлены  тела (т.е. конкретные 
реализации) методов, описанных в этом интерфейсе.  Каждому классу предоставляется полная свобода в 
определении деталей своей собственной реализации  интерфейса.  Следовательно, один  и тот же 
интерфейс может быть реализован в двух классах по-разному. Тем не менее в каждом из них должен 
поддерживаться один и тот же ряд методов данного интерфейса. А в том  коде, где  известен такой  
интерфейс,  могут использоваться объекты любого из этих двух классов, поскольку интерфейс для всех 
этих объектов остается одинаковым. Благодаря поддержке интерфейсов в Java может быть в полной  
мере реализован главный принцип полиморфизма: “один интерфейс — множество методов”.

Прежде чем продолжить изучение материала, сделаем одно важное замечание.  В JDK 8 интерфейсы 
существенно изменились.  В версиях, предшествующих JDK 8, интерфейс не мог определять какую-либо 
реализацию, т.е. в этих версиях интерфейс мог определять, что делать, но не как делать, как было 
только что отмечено.  В JDK 8 все  изменилось,  и теперь можно добавить в метод интерфейса 
реализацию по умолчанию. Более того, теперь поддерживаются методы статического интерфейса, а 
начиная с версии JDK 9 интерфейс может также включать закрытые методы. Все это привело к тому, что 
интерфейс может проявлять некоторое поведение. Но подобные методы по сути являются средствами 
специального назначения, а исходное предназначение интерфейса остается без изменений. Поэтому, как 
правило, вы по-прежнему будете часто создавать и использовать интерфейсы, в которых не будут 
применяться эти  новые средства. Поэтому мы  начнем рассматривать интерфейсы в их традиционной 
форме, а новые средства интерфейсов будут описаны в конце этой главы.

Интерфейсы объявляются с помощью ключевого слова interface.  Ниже приведена упрощенная форма объявления интерфейса
доступ interface имя  {
    возвращаемый_тип  имя_метода_1 ( список_параметров) ;
    возвращаемый_тип  имя_метода_2 (список_параметров) ;
    тип  переменная_1  =  значение;
    тип  переменная_2  =  значение;
    // ...
    возвращаемый_тип  имя_метода_N( список_параметров) ;
    тип  переменная_N = значение;
}

Здесь доступ обозначает тип доступа, который определяется модификатором доступа public  или вообще 
не указывается.  Если  модификатор доступа отсутствует,  применяется  правило,  предусмотренное  
по умолчанию, т.е.  интерфейс считается доступным только членам своего пакета.  Ключевое слово 
public  указывает на то, что интерфейс может использоваться в любом другом пакете. (Код 
интерфейса, объявленного как public , должен храниться в файле, имя которого совпадает с именем 
интерфейса.) А имя интерфейса может быть любым допустимым идентификатором.

При объявлении методов указываются их сигнатуры и возвращаемые типы. Эти  методы являются,  по 
сути,  абстрактными.  Как упоминалось выше,  реализация метода не может содержаться в составе 
интерфейса.  Каждый класс, в определении которого указан интерфейс, должен реализовать все методы, 
объявленные в интерфейсе. Методы, объявленные в интерфейсе, неявно считаются открытыми (public).
Переменные, объявленные в интерфейсе, не являются переменными экземпляра. Они неявно обозначаются 
ключевыми словами public ,  final и static  и обязательно подлежат инициализации. По сути, они 
являются константами. Ниже приведен пример определения интерфейса. Предполагается, что этот 
интерфейс должен быть реализован в классе, где формируется последовательный ряд числовых значений.

public interface Series  {
    int getNext();  // возврат следующего по порядку числа
    void reset();   //  сброс
    void setStart(int х);  // установка начального значения
}

Этот интерфейс объявляется открытым (public), а следовательно,  может быть реализован в классе, 
принадлежащем любому пакету