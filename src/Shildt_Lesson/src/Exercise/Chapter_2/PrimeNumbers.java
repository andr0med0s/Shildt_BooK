package Shildt_Lesson.src.Exercise.Chapter_2;
// стр 98
// Напишите программу, которая находила бы все простые числа в диапазоне
//от 2 до 100.
public class PrimeNumbers {
    public static void main(String[] args) {
        int i, j;
        boolean isprime;

        for (i = 2; i < 100; i++) {
            isprime = true;

            // Проверить делится ли число без остатка
            for (j = 2; j <= i / j; j++)
                // Если число делится без остатка, значит, оно не простое
                if ((i % j) == 0)
                    isprime = false;

            if (isprime)
                System.out.println(i + " - простое число");
        }
    }

    /*
     * По поводу данного условия ( j <= i/j ) - это одна из возможностей быстрого
     * перебора множителей простых чисел в частности (здесь читать про Простые числа
     * надо).
     * Наглядным примером будет проверка на "Простое" числа 121.
     * Так, для числа i - 121, j будет максимум 11, соответственно цикл будет
     * выполняться в таком порядке:
     * j=2 <= 121/2; j=3 <=121/3... ...j=11 <=121/11; далее перебор не нужен будет,
     * так как это как раз число на которое 121 делится без остатка.
     * Я в математику не углублялся, но как я понял, если у числа не найден делитель
     * до числа соответствующего его корню (ведь 11 корень 121), то дальше уже целый
     * делитель не будет найден, и число является Простым.
     */

    /*
     * Простые числа это те которые нацело делятся только на 1 и на само себя.
     * 
     * Например 2 - это простое число, т.к. оно делится на 1 и на 2. А вот 6 делится
     * на 1, 2, 3, 6 и является составным.
     * 
     * Поэтому второй цикл необходим всего лишь для того чтобы пробежаться по всем
     * делителям числа.
     * 
     * Но длительность этого цикла можно сократить двумя способами:
     * 
     * до j <= i / 2, т.к. после этого пойдут делители, которые никогда не могут
     * поделить число нацело и в любом случае при делении будет что то дробное в
     * промежутке от 1 до 2.
     * 
     * до квадратного корня: j <= Math.sqrt(i). Почему так можно?
     * 
     * Возьмем число 16. У него есть следующие делители:
     * 
     * 16 : 1 = 16
     * 
     * 16 : 2 = 8
     * 
     * 16 : 4 = 4
     * 
     * 16 : 8 = 2
     * 
     * 16 : 16 = 1
     * 
     * После 4 все делители как будто бы отзеркаливаются. Это происходит после
     * квадратного корня. Но так как квадратный корень это нечто дробное, то
     * желательно округлить его и прибавить 1 или 2, чтобы точно быть уверенным что
     * вы не пропустили, например делитель 7 в числе 49.
     * 
     * Полный код программы такой:
     * 
            * for (int n = 2; n <= 100; n++) {
            * boolean isPrime = true;
            * double squareRoot = Math.sqrt(n) + 2;
            * int r = 2;
            * while (r <= squareRoot && isPrime) {
            * if (n % r == 0) isPrime = false;
            * r++;
            * }
            * System.out.print(isPrime ? (n + " ") : "");
            * }
     * 
     */
}
